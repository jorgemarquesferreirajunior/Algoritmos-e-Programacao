#include <Arduino.h>
#include "Globals.hpp"
#include "HardwareSerial.h"
#include "MyTasks.hpp"
#include "esp32-hal-gpio.h"

/*
| Endereço | Tipo           | Função                                    |
| -------- | -------------- | ----------------------------------------- |
| 00001    | Coil           | LED1 ON/OFF                               |
| 00002    | Coil           | LED2 ON/OFF                               |
| 00003    | Coil           | LED3 ON/OFF                               |
| 00004    | Coil           | LED4 ON/OFF                               |
| 00005    | Coil           | Motor ON/OFF                              |
| 40001    | Holding Reg.   | Velocidade setpoint motor (0–100%)        |
| 40002    | Holding Reg.   | Contador peças tipo 1                     |
| 40003    | Holding Reg.   | Contador peças tipo 2                     |
| 10001    | Discrete Input | Sensor 1 (entrada esteira)                |
| 10002    | Discrete Input | Sensor 2 (peça tipo 1)                    |
| 10003    | Discrete Input | Sensor 3 (peça tipo 2)                    |
| 10004    | Discrete Input | Sensor 4 (saída esteira)                  |
| 30001    | Input Reg.     | Velocidade atual do motor (potenciômetro) |
*/


/*
    ///////////////////////////////////////
    TESTES FUNCAO 0x01 : WRITE SINGLE COIL
    ///////////////////////////////////////

    Liga
    0x06 0x05 0x00 0x10 0xff 0x00 0x8c 0x48
    0x06 0x05 0x00 0x11 0xff 0x00 0xdd 0x88
    0x06 0x05 0x00 0x12 0xff 0x00 0x2d 0x88
    0x06 0x05 0x00 0x13 0xff 0x00 0x7c 0x48
    0x06 0x05 0x00 0x14 0xff 0x00 0xcd 0x89
    0x06 0x05 0x00 0x15 0xff 0x00 0x9c 0x49

    Desliga
    0x06 0x05 0x00 0x10 0x00 0x00 0xcd 0xb8
    0x06 0x05 0x00 0x11 0x00 0x00 0x9c 0x78
    0x06 0x05 0x00 0x12 0x00 0x00 0x6c 0x78
    0x06 0x05 0x00 0x13 0x00 0x00 0x3d 0xb8
    0x06 0x05 0x00 0x14 0x00 0x00 0x8c 0x79
    0x06 0x05 0x00 0x15 0x00 0x00 0xdd 0xb9

    Teste excecao 0x01: Funcao invalida
    0x06 0x0d 0x00 0x12 0xff 0x00 0xcc 0x49

    Teste excecao 0x02: Endereco invalido
    0x06 0x05 0x00 0x15 0xff 0x00 0x9c 0x49

    Teste excecao 0x03: Valor invalido
    0x06 0x05 0x00 0x12 0xff 0x02 0xac 0x49
*/

/*
    ///////////////////////////////////////
    TESTES FUNCAO 0x01 : READ COILS
    ///////////////////////////////////////

    0x06 0x01 0x00 0x10 0x00 0x04 0x3d 0xbb
    0x06 0x01 0x00 0x12 0x00 0x03 0xdd 0xb9
    0x06 0x01 0x00 0x10 0x00 0x05 0xfc 0x7b
    0x06 0x01 0x00 0x14 0x00 0x05 0xbd 0xba
    0x06 0x01 0x00 0x10 0x00 0x06 0xbc 0x7a

    Teste excecao 0x01: Funcao invalida
    0x06 0x0d 0x00 0x10 0x00 0x04 0x2d 0xba

    Teste excecao 0x02: Endereco invalido
    0x06 0x01 0x00 0x09 0x00 0x04 0xec 0x7c

    Teste excecao 0x03: Valor invalido
    0x06 0x01 0x00 0x10 0x00 0x0a 0xbc 0x7f

    /////////////////////////////////////////
    TESTES FUNCAO 0x02 : READ DISCRETE INPUTS
    /////////////////////////////////////////

    0x06 0x02 0x00 0x20 0x00 0x06 0xf8 0x75
    0x06 0x02 0x00 0x21 0x00 0x05 0xe9 0xb4
    0x06 0x02 0x00 0x25 0x00 0x06 0xe8 0x74

    Teste excecao 0x01: Funcao invalida
    0x06 0x0c 0x00 0x20 0x00 0x06 0x91 0xb4

    Teste excecao 0x02: Endereco invalido
    0x06 0x02 0x00 0x26 0x00 0x06 0x18 0x74

    Teste excecao 0x03: Valor invalido    0x06 0x02 0x00 0x20 0x00 0x07 0x39 0xb5

    /////////////////////////////////////////
    TESTES FUNCAO 0x02 : READ HOLDING REGISTERS
    /////////////////////////////////////////
    0x06 0x03 0x00 0x30 0x00 0x03 0x04 0x73

    /////////////////////////////////////////
    TESTES FUNCAO 0x02 : READ INPUT REGISTERS
    /////////////////////////////////////////
    0x06 0x04 0x00 0x40 0x00 0x01 0x31 0xa9
    0x06 0x04 0x00 0x40 0x00 0x03 0xb0 0x68
*/

void setup()
{

    Serial.begin(BAUDRATE, SERIAL_8N1);
    /*
    * Cálculo do tempo de fim de quadro Modbus RTU em ms
    * Para 8-N-1 temos 11 bits/byte:
    * (3,5 bytes * 11 bits/byte * 1000 ms/s) / 9600 bits/s ≈ 4 ms
    */
    endFrameTime = ((3.5 * 11 * 1000) / BAUDRATE);
    endFrameTime ++;                            // Soma 1ms para garantir o tempo minimo para termino do recebimento de dados

    // Configuracao do endero do escravo 
    SLAVE_ADDRRES = 0;
    SLAVE_ADDRRES |= digitalRead(BINARY_ADDR1) << 0;
    SLAVE_ADDRRES |= digitalRead(BINARY_ADDR2) << 1;
    SLAVE_ADDRRES |= digitalRead(BINARY_ADDR3) << 2;

    // Configuração do hardware
    for (unsigned short i = 0; i < N_COILS; i++) pinMode(COILS_MAP[i], OUTPUT);
    for (unsigned short i = 0; i < N_DINPUTS; i++) pinMode(DINPUTS_MAP[i], INPUT_PULLUP);


    // task1
    xTaskCreatePinnedToCore(taskConveyor, "GerenciadorEsteira", 4096, NULL, 1, NULL, 0);
    // task2
    xTaskCreatePinnedToCore(taskModbus, "GerenciadorModbusRTU", 4096, NULL, 1, NULL, 1);
    
    // Inicializacao dos vetores de recebimento e resposta
    memset(receivedData, 0x00, sizeof(receivedData));
    memset(respData, 0x00, sizeof(respData));
    memset(HREGS_MAP, 0x00, N_HREGS * sizeof(unsigned short));
    
    tempTime = millis();

    // Pino DE/RE da RS-485 (caso esteja usando um transceiver)
    // pinMode(RS485_ENABLE, OUTPUT);
    // digitalWrite(RS485_ENABLE, LOW);  // Modo recepção

}
void loop(){}
